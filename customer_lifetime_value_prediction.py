# -*- coding: utf-8 -*-
"""Customer Lifetime Value Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qXzlhmUETP3cf0upsq9fJVVdsLxShC5Z

Importing Libraries
"""

!pip install lifetimes

import datetime as dt
import pandas as pd
import matplotlib.pyplot as plt
from lifetimes import BetaGeoFitter
from lifetimes import GammaGammaFitter
from lifetimes.plotting import plot_period_transactions

pd.set_option('display.max_columns', None)
pd.set_option('display.width', 500)
pd.set_option('display.float_format', lambda x: '%.4f' % x)
from sklearn.preprocessing import MinMaxScaler

"""loading dataset"""

from google.colab import files
upload = files.upload()

"""Reading Dataset"""

df_ =pd.read_csv("/content/online_retail_II.csv.zip")
df = df_.copy()
df.tail()

df.shape

df.dtypes

df.isnull().sum()

df.describe().T

"""Data Preprocessing"""

df.dropna(inplace=True)
df = df[df['Quantity']>0]
df = df[df['Price']>0]

describe_list = [0.01, 0.05, 0.95, 0.99]
df.describe(describe_list).T

"""Outliers"""

def outlier_thresholds(dataframe, variable):
    quartile1 = dataframe[variable].quantile(0.01)
    quartile3 = dataframe[variable].quantile(0.99)
    interquantile_range = quartile3 - quartile1
    up_limit = quartile3 + 1.5 * interquantile_range
    low_limit = quartile1 - 1.5 * interquantile_range
    return low_limit, up_limit


def replace_with_thresholds(dataframe, variable):
    low_limit, up_limit = outlier_thresholds(dataframe, variable)
    dataframe.loc[(dataframe[variable] < low_limit), variable] = low_limit
    dataframe.loc[(dataframe[variable] > up_limit), variable] = up_limit

replace_with_thresholds(df, 'Quantity')
replace_with_thresholds(df, 'Price')

df['Total_Price'] = df['Quantity']*df['Price']
df['Customer ID'] = df['Customer ID'].astype(int)

df['InvoiceDate'] = pd.to_datetime(df['InvoiceDate'])
df['InvoiceDate'].max()

#Analysis Date
today_date = dt.datetime(2011, 12, 10)

"""Preparing Lifetime Data Structure"""

cltv_df = df.groupby('Customer ID').agg({'InvoiceDate':[lambda x: (x.max()- x.min()).days,
                                                        lambda x: (today_date - x.min()).days],
                                         'Invoice':lambda x: x.nunique(),
                                         'Total_Price':lambda x: x.sum()})

cltv_df

cltv_df.columns = cltv_df.columns.droplevel(0)

cltv_df.columns = ['recency', 'T', 'frequency', 'monetary']
cltv_df["monetary"] = cltv_df["monetary"] / cltv_df["frequency"]
cltv_df = cltv_df[(cltv_df['frequency'] > 1)]
cltv_df["recency"] = cltv_df["recency"] / 7 #Weekly
cltv_df["T"] = cltv_df["T"] / 7 #Weekly

cltv_df

"""BG/NBD MODEL"""

bgf = BetaGeoFitter(penalizer_coef=0.001) #For preventing overfit
bgf.fit(cltv_df['frequency'],
        cltv_df['recency'],
        cltv_df['T'])

#Who are the 5 customers we expect to purchase the most from in 1 week?
bgf.conditional_expected_number_of_purchases_up_to_time(1,
                                                        cltv_df['frequency'],
                                                        cltv_df['recency'],
                                                        cltv_df['T']).sort_values(ascending=False).head()

cltv_df["expected_purc_1_week"] = bgf.predict(1,
                                              cltv_df['frequency'],
                                              cltv_df['recency'],
                                              cltv_df['T'])

#Who are the 5 customers we expect to purchase the most from in 1 month?
#conditional_expected_number_of_purchases_up_to_time = predict
bgf.predict(4, #4 week =1 month
            cltv_df['frequency'],
            cltv_df['recency'],
            cltv_df['T']).sort_values(ascending=False).head()

cltv_df["expected_purc_1_month"] = bgf.predict(4,
                                               cltv_df['frequency'],
                                               cltv_df['recency'],
                                               cltv_df['T'])

#What is the total purchase estimate in 1 month?
bgf.predict(4,
            cltv_df['frequency'],
            cltv_df['recency'],
            cltv_df['T']).sum()

"""Evaluation of Forecast Results"""

plot_period_transactions(bgf)
plt.show()

"""GAMMA-GAMMA MODEL"""

ggf = GammaGammaFitter(penalizer_coef=0.01)
ggf.fit(cltv_df['frequency'], cltv_df['monetary'])
ggf.conditional_expected_average_profit(cltv_df['frequency'], cltv_df['monetary']).sort_values(ascending=False).head(5)

cltv_df['expected_average_profit'] = ggf.conditional_expected_average_profit(cltv_df['frequency'],
                                                                             cltv_df['monetary'])

"""Calculation of Customer Lifetime Value with BG-NBD and GG model"""

cltv = ggf.customer_lifetime_value(bgf,
                                   cltv_df['frequency'],
                                   cltv_df['recency'],
                                   cltv_df['T'],
                                   cltv_df['monetary'],
                                   time=3, #3 months
                                   freq='W', #weekly,
                                   discount_rate=0.01)
cltv.head()

cltv= cltv.reset_index()
cltv_final = cltv.merge(cltv_df, how='right', on='Customer ID')
cltv_final.sort_values(by="clv", ascending=False).head()

"""Customer Segmentation Based on CLTV"""

cltv_final['segment'] = pd.qcut(cltv_final['clv'], 4, labels=['D', 'C', 'B', 'A'])

cltv_final.groupby('segment').agg({'count', 'mean', 'sum'})